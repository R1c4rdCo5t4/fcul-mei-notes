# Static Code Analysis
- **Objective:** find vulnerabilities in the applications' source code **automatically**
	- Similarly to compilers' error checking but for security bugs
	- Similarly to manual code reviewing but automatically
- The code **is not executed**
- Some tools can analyze **binary** or **intermediate** code, but analyzing **source code** is simpler so it's more common
- Example: **Flawfinder**

### Simples Static Analysis Tools
- **Main components:**
	- **Database** of vulnerable system/library calls
	- **Code preprocessor** to check what to be compiled
	- **Lexical analyzer** to get the call names and locations in the original code, producing a sequence of tokens
- Example:
```javascript
// source code
if (ret) mat[x][y] = END_VAL;

// generated stream of tokens
IF LPAREN ID(RET) RPAREN ID(mat) LBRACKET ID(x) RBRACKET LBRACKET ID(y) RBRACKET EQUAL ID(END_VAL) SEMI
```

### Goals and Limitations
- These tools generate many false positives, so the quest in the area is for 2 goals:
	- **Find all vulnerabilities** → **no false negatives**
	- **Minimize the number of false positives**
- Expected results:
	- Limited scope (false negatives)
		- Only find the type of flaws they are programmed to look for
		- Analysis is necessarily limited
		- More detailed analysis can take a long time
	- Tend to generate many false positives
		- **Tradeoff:** false positives vs false negatives
		- Manual work is still needed
	- **Not a solution to all problems**

### Fundamental Limitation
- Static analysis tries to solve a **computationally undecidable problem** - the halting problem (Turing)
- Perfect analysis of a property can be shown to require solving the halting problem
- This doesn't mean that it is not useful, only that it cannot be proven to find all problems of a certain set

### Types of Static Analysis Tools
- **String matchers**
	- Run directly over source code (before lexical analysis)
	- *grep*, *findstr*
- **Lexical analyzers**
	- Run over the tokens generated by the scanner
	- Names are not confused (different tokens)
	- *RATS*, *Flawfinder*
- **Semantic analyzers**
	- Run over the syntax tree generated by the parser
- **Syntactic analyzers**:
    - Ensure tokens follow grammatical rules of the language
    - Focuses on relationships and structure of tokens

# Semantic Analysis
- **Syntax/Parse Tree**
	- The parser uses a *context-free grammar (CFG)* to match the token stream and then derive a **parse tree**
- **Abstract Syntax Tree (AST)**
	- Builds a **model of the program** in AST
	- Performs lexical analysis and parsing
	- Generate simultaneously a **symbol table**, which associates to each identifier the type and a pointer to its definition/declaration.

### Type Checking Analysis
- **Data types** are used to limit how variables are used
- Type checking is done by compilers and interpreters
- Verification based on the type systems of programming languages is important but limited for security
- Such type checking can find some integer manipulation vulnerabilities:
	- **Signedness:** signed integer is attributed to an unsigned (or vice-versa)
	- **Truncation:** integer represented with N bits is assigned to an integer variable with less than N bits (e.g., int to short)
- The language can use static or dynamic types

### Control-Flow Analysis
- Basic idea is to **follow the control paths of a program doing checks**
	- Can be performed at the function/module/program level
	- Applies a set of rules to each one of the paths
	- Can be used for doing local control flow analysis and data-flow analysis
- Can be:
	- **Local Analysis**
		- Analyses one function at a time
		- Does not consider the relations among them
	- **Module-Level Analysis**
		- One class or compilation unit at a time based on the models generated by local analysis
		- Does not consider relations among modules
	- **Global Analysis**
		- Analysis the whole program, given the previous analysis of functions and modules → you can use a call graph
- A **call graph** represents potential control flow between functions or methods - Can be used for doing global control flow analysis/data-flow analysis
- **Data-Flow Analysis**
	- Tries to understand **how data moves** through the program, namely from the input (attack surface) to dangerous instructions
	- Typically involves traversing a function's *control flow graph* and noting where data values are generated and where they are used
	- **Taint analysis:** follow the input data and verify if it reaches functions that can be exploited with malicious inputs

### WAP (Web Application Protection)
- **Objective:** detect and remove input validation vulnerabilities in web applications programmed in PHP
- The removal of vulnerabilities is performed by adding fixes to the source code
- **Mechanisms:**
	- Semantic analysis
	- Data flow analysis (taint analysis)

### Symbolic Execution
- Emulate the execution of the program
	- Using **symbolic input values**, instead of concrete data values
	- Represent the values of program variables as **symbolic expressions** over the symbolic input values
	- **Output values** computed by the program are expressed as a function of the symbolic input values
- **Main goals** for software testing:
	- High coverage test suites
	- Provide developers with concrete inputs that triggers bugs 
- All execution paths of the program can be represented in an **execution tree**

#### Difficulties
- **Symbolic path explosion** - as more if conditions are encountered in the program, there are too many path constraints to be solved
- Code containing **loops** and **recursion** - may result in an infinite number of paths
- Symbolic paths with **unsolvable constraints**
- **Solutions:**
	- Timeout for the processing
	- Limit on the number of paths
	- Limit on the number of iterations
	- Limit on exploration depth
- However, all of these cause imprecisions on the analysis

#### Concolic Execution
- Performs concolic execution **dynamically** while the program is "executed" on some concrete input values
- While executing the tool maintains a:
	- **Concrete state** that maps all variables to their concrete values
	- **Symbolic state** that **only** maps variables that have non-concrete values